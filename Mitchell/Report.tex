\documentclass[runningheads,a4paper]{llncs}

\usepackage[utf8]{inputenc}

\usepackage[square,sort,comma,numbers,sectionbib]{natbib}
\bibliographystyle{apalike-fr}
\renewcommand{\bibname}{References}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{amsopn}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{todonotes}

\topmargin=0in
\evensidemargin=0.25in
\oddsidemargin=0.25in
\textwidth=6in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1}

%Blackboard Bold
\newcommand{\C}{\mathbb{C}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\N}{\mathbb{N}}

%Calligraphic
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cL}{\mathcal{L}}

%Greek
\renewcommand{\a}{\alpha}
\newcommand{\z}{\zeta}
\renewcommand{\b}{\beta}
\newcommand{\g}{\gamma}
\newcommand{\e}{\varepsilon}
\renewcommand{\d}{\delta}
\renewcommand{\r}{\rho}
\renewcommand{\l}{\lambda}
\newcommand{\w}{\omega}
\newcommand{\n}{\eta}
\newcommand{\f}{\varphi}
\newcommand{\s}{\sigma}
\renewcommand{\t}{\tau}
\newcommand{\tr}{\tilde \rho}


%Sets and Logic
\newcommand{\sub}{\subseteq}
\newcommand{\imp}{\implies}
\newcommand{\x}{\times}
\DeclareMathOperator{\End}{End}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\im}{im}
\renewcommand{\-}{\setminus}
\DeclareMathOperator{\id}{id}

%Linear Algebra
\newcommand{\bop}{\bigoplus}
%\newcommand{\tr}{\text{tr}}

\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\begin{document}

\mainmatter 

\title{Group Theory in Lean}

\titlerunning{Group Theory in Lean}

\author{Mitchell Rowett}

\institute{Interactive Theorem Proving}

\authorrunning{Mitchell Rowett}

\toctitle{Abstract}
\tocauthor{{}}

\maketitle

\medskip

\begingroup
\let\clearpage\relax
\tableofcontents
\endgroup

\section*{Abstract}

In this report, we describe a formalisation of elementary group theory in the proof assistant Lean. We begin with an introduction to interactive theorem proving, and to the Lean Theorem Prover in particular. We then detail the construction of this formalisation in Lean, culminating in a proof of the first isomorphism theorem.

\section{Introduction}

Computational formal verification of mathematical theorems comes in two main forms. Automated theorem proving focuses on proving assertions fully automatically, with little or no input from a user. Interactive theorem proving involves a user actively guiding the proof, and builds mathematical structures from a suitable axiomatic framework.

Lean is primarily an interactive theorem prover, with a variety of automated tools. It encodes a formal mathematical language, based on dependent type theory, as well as a method for checking the correctness of terms written in this language.

\section{Lean Theorem Prover}

Lean is a proof assistant which encodes a variety of dependent type theory (described below) and provides a method for checking derivations made in that encoding. Lean also provides many features which aid the user in defining objects and proving theorems, the most relevant of which are discussed later in this section.

\subsection{Type Theory}

A type theory is a formal system in which every term has a type, and operations are restricted to terms of a certain type. It is built by specifying judgments and rules. The basic judgment in type theory is of the form $a : A$, which is read as the statement `a is a term of type A'. Further, operations can be defined with types. The judgment $f : A \to B$ is the statement that $f$ has the type of a function with domain $A$ and co-domain $B$.

Type theory allows the construction of further objects, given prior judgments. For example, the expression
\[
4 * (5 + 7) : \textbf{nat}
\]
is a type judgment states that $4 * (5 + 7)^8$ is of type \textbf{nat}, which is true because 4, 5, and 7 are of type \textbf{nat}, while $*$ and $+$ are operations on natural numbers.\\

The simple type theory described above is limited in that the only types which exist are the types built into the language and those which can be constructed using $\to$ (i.e. functions from one type to another). Simple type systems generally have other simple constructions as well -- for example, a conjuction operator which gives types of the form $A \land B$.

There are many types which cannot be described using this system -- for example, a list of terms where all the terms are of type $A$, expressed as the type `list $A$'. The construction of this type clearly depends on the type $A$, hence a type theory where constructions of this form are possible is called a dependent type theory.\\

Type systems are commonly used in programming languages to check the syntactic correctness of code. For example, if $x$ is given as an argument to a function which takes an integer as an argument, then a type system as described above can be used to check whether $x$ indeed has the type integer, and so can provide a compile-time check of the syntactic correctness of the program.

Proof assistants can use the same method of type checking to ensure the correctness of a mathematical proof of some theorem, by relying on the Curry-Howard isomorphism. The isomorphism simply amounts to a correspondence between two possible readings of the judgment
\[
p : A
\]
\begin{itemize}
\item $p$ is a term (variable, function output) of the data type $A$
\item $p$ is a proof of the hypothesis $A$
\end{itemize}

To generalise, the former is how a programmer would understand the judgment, while the latter is the point of view of a proof theorist. Interactive theorem provers use both, in which a term (proof) of the correct type (hypothesis) is sought interactively by both the user and the system. In other words, a type checking algorithm can be used to check whether $p$ is a correct proof of the hypothesis $A$, as this will be the case if and only if $p$ is a correct term of the type $A$.

In this manner, Lean encodes a dependent type theory called the Calculus of Inductive Constructions (CIC).

\subsection{Elaboration}

One issue proof assistants run into is that building more complex structures can require a lot of details. In 'pen-and-paper' mathematics, these details are omitted as they can be easily inferred.

To facilitate this, Lean has an elaborator, which allows the user to leave arguments implicit by putting them in curly brackets when defining a function. The elaborator will then convert this partially specified expression into a fully specified, type correct term. For example, Lean defines the identity function as

\vspace{2 mm}
\hspace{2 em}\textbf{def id \{$\a$ : Type\} (a : $\a$) : $\a$ := a}
\vspace{2 mm}

Unpacking this definition will show most of the essential lean syntax. The \textbf{def} keyword creates a function called \textbf{id}. The next two terms, \textbf{\{$\a$ : Type\} (a : $\a$)}, are arguments to the function -- $\a$ is a Type, while \textbf{a} is a term of type $\a$. The syntax \textbf{: $\a$} means that the result of the function will be a term of type $\a$, and \textbf{:= a} is the result of the function -- given a type $\a$ and a term of that type \textbf{a}, return \textbf{a}.

Note, however, the difference between the syntax of the two arguments. The use of curly brackets allows the user to write \textbf{id a} rather than \textbf{id A a}. The elaborator can infer the type required.\\

The elaborator also supports overloading. For example, we later use the following: let $a$ and $b$ be elements of a group $G$, and $S$ a subgroup of $G$. Then $a*b$ is used to denote group multiplication, while $a * S$ is used to denote the left coset of $S$ by $a$. The elaborator also inserts coercions (for example, from \textbf{nat} to \textbf{int}) where necessary.

\subsection{Type Class Inference}

Another way in which the elaborator allows details to be omitted is through type class inference, which works as follows. First, a structure is marked as a class. Then, an instance of this class is declared, either by adding it as a hypothesis or by proving that it must be present due to existing hypotheses. Finally, in any definition/theorem/lemma in which this structure is used, we can mark the argument as implicit using square brackets rather than curly brackets, which informs the elaborator that these arguments should be inferred by the type class mechanism.

A relevant example of type class inference is the construction of the group structure.

\subsection{Group Construction}

Without any kind of implicit arguments, the statement $\forall a\; b : \a,\; a*b : \a$ would be insufficient on its own. We would need to give as an argument to $*$ the fact that multiplication on terms of type $\a$ is actually possible. However, using type class inference we can get around this:

\vspace{2 mm}
\hspace{2 em}\textbf{class has\_mul ($\a$ : Type u) := (mul : $\a \to \a \to \a$)}
\vspace{2 mm}

This means that a proof or hypothesis \textbf{$p$ : has\_mul $\a$} is the statement that $\a$ is a type with multiplication, and so we can write (for example) $\forall a\; b : \a,\; a*b : \a$. Further, since it is a class, we do not have to explicitly tell Lean that this is possible. So long as $p$ is in the context, we can write $a * b$, and the elaborator will use type class inference to check that multiplication on terms of type $\a$ is possible.

Type class inference can also use the information that one type marked as a class inherits from another type marked as a class. For example:

\vspace{2 mm}
\hspace{2 em}\textbf{class semigroup ($\a$ : Type u) extends has\_mul $\a$
 := }

\hspace{4 em}\textbf{(mul\_assoc : $\forall a\; b\; c : \a,\; a * b * c = a * (b * c)$)}
\vspace{2 mm}

Since \textbf{semigroup} inherits from \textbf{has\_mul}, one of the implicit fields of \textbf{semigroup} is \textbf{(mul : $\a \to \a \to \a$)}. Given \textbf{[h : semigroup $\a$]} in the context, we can write $a * b$ and Lean will recognise that \textbf{semigroup} inherits from \textbf{has\_mul}, and so can use type class inference to check that multiplication on terms of type $\a$ is possible.

We will now quickly show the remaining steps required to create a group structure. First, it is necessary for the type to have an identity element:

\vspace{2 mm}
\hspace{2 em}\textbf{class has\_one ($\a$ : Type u) := (one : $\a$)}
\vspace{2 mm}

This allows us to create the monoid structure:

\vspace{2 mm}
\hspace{2 em}\textbf{class monoid ($\a$ : Type u) extends semigroup $\a$, has\_one $\a$ := }

\hspace{4 em}\textbf{(one\_mul : $\forall a : \a,\; 1 * a = a$) (mul\_one : $\forall a : \a,\; a * 1 = a$)}
\vspace{2 mm}

It is also necessary for every term of the type to have an inverse:

\vspace{2 mm}
\hspace{2 em}\textbf{class has\_inv ($\a$ : Type u) := (inv : $\a \to \a$)}
\vspace{2 mm}

Finally we can create the group structure:

\vspace{2 mm}
\hspace{2 em}\textbf{class group ($\a$ : Type u) extends monoid $\a$, has\_inv $\a$ := }

\hspace{4 em}\textbf{(mul\_left\_inv : $\forall a : \a,\; a^{-1} * a = 1$)}
\vspace{2 mm}

If we were to write every field of the group structure explicitly, it would be:

\vspace{2 mm}
\hspace{2 em}\textbf{class group ($\a$ : Type u) := }

\hspace{4 em}\textbf{(mul : $\a \to \a \to \a$)}

\hspace{4 em}\textbf{(mul\_assoc : $\forall a\; b\; c : \a,\; a * b * c = a * (b * c)$)}

\hspace{4 em}\textbf{(one : $\a$)}

\hspace{4 em}\textbf{(one\_mul : $\forall a : \a,\; 1 * a = a$)}

\hspace{4 em}\textbf{(mul\_one : $\forall a : \a,\; a * 1 = a$)}

\hspace{4 em}\textbf{(inv : $\a \to \a$)}

\hspace{4 em}\textbf{(mul\_left\_inv : $\forall a : \a,\; a^{-1} * a = 1$)}
\vspace{2 mm}

\section{Group Theory}

In this section we will review the elementary group theory\cite{artin} which will be formalised in this report.

\begin{definition}[Group] 
A group is a set $G$ together with an operation $* : G \times G \to G$, which we will call multiplication, such that:
\begin{itemize}
\item $G$ is closed under multiplication: for all $a$ and $b$ in $G$, $a*b$ in $G$
\item Multiplication is associative: for all a, b, c, in $G$, $(a*b)*c = a*(b*c)$
\item G contains an identity element 1: for all a in $G$, $1*a = a$ and $a*1=a$
\item Every element $a$ of $G$ has an inverse, an element $b$ such that $a*b = 1$ and $b*a =1$
\end{itemize}

We denote the inverse of $a$ as $a^{-1}$.
\end{definition}

\subsection{Subgroups}

\begin{definition}[Subgroup]
A subset $H$ of a group $G$ is a subgroup if it has the following properties:
\begin{itemize}
\item Closure: If a and b are in H, then $a * b$ is in H
\item Identity: 1 is in H
\item Inverses: If a is in H, then $a^{-1}$ is in H
\end{itemize}
\end{definition}

\begin{definition}[Normal]
A subgroup N of a group G is a normal subgroup if for every a in N and every g in G, $g * a * g^{-1}$ is in N.
\end{definition}

\begin{definition}[Trivial Subgroup] The set containing only 1 is a subgroup, and is called the trivial subgroup.
\end{definition}

\begin{definition}[Center]
The center of a group G is the set of elements that commute with every element of G:
\[
\left\{ z \in G \mid z*x = x*z \text{ for all } x \in G \right\}
\]
\end{definition}

\begin{definition}[Left Coset]
If H is a subgroup of a group G and a is an element of G, then the left coset of H by a is 
\[
a * H = \{ g \in G \mid g = a * h \text{ for some } h \in H \}
\]
We similarly define the right coset of H by a and denote it $H * a$.
\end{definition}

\subsection{Homomorphisms}

\begin{definition}[Homomorphism]
Homomorphism: Let G and G' be groups. A homomorphism $\phi : G \to G'$ is a map from G to G' such that for all a, b in G:
\[
\phi (a * b) = \phi(a) * \phi(b)
\]
\end{definition}

\begin{definition}[Kernel]
Suppose G and G' are groups, and let $\phi : G \to G'$ be a homomorphism. The kernel of $\phi$ is the set of elements of G which are mapped to the identity in G'.
\[
\left\{ a \in G \mid \phi(a) = 1 \right\}
\]
\end{definition}

\begin{definition}[Quotient Group]
Let G be a group, and N a normal subgroup. Then there is an equivalence relation on elements of G, given by $a \sim b$ if $a * b^{-1} \in N$. The equivalence class of b given by this relation is denoted $[b]$, and the set of equivalence classes is denoted $G/N$. $G/N$ is a group, and is called the quotient of G by N.
\end{definition}

\begin{definition}[Isomorphism]
A homomorphism is called an isomorphism if it is bijective. Two groups are said to be isomorphic if there exists an isomorphism between them.
\end{definition}

\begin{theorem}[First Isomorphism Theorem]
Let G and G' be groups, and let $\phi : G \to G'$ be a homomorphism. Let K be the kernel of $\phi$. Note that the image of $\phi$ forms a group. Then $G/K$ is isomorphic to the image of $\phi$.
\end{theorem}

\section{Subgroups}

Given the definition of a subgroup described in section 3, we define a subgroup as follows.

\vspace{2 mm}
\hspace{2 em}\textbf{class is\_subgroup [group $\a$] (s : set $\a$) : Prop :=}

\hspace{4 em}\textbf{(mul\_mem : $\forall \{a\; b\},\; a \in s \to b \in s \to a * b \in s$)}

\hspace{4 em}\textbf{(one\_mem : $(1 : \a) \in s$)}

\hspace{4 em}\textbf{(inv\_mem : $\forall \{a\},\; a \in s \to a^{-1} \in s$)}
\vspace{2 mm}

\textbf{is\_subgroup} takes as its only explicit argument a set of $\a$, with which it will try to find an instance of the fact that $\a$ is a group. \textbf{is\_subgroup s} is of type \textbf{Prop}, as it is the proposition that $s$ is a subgroup.

This distinction is important. \textbf{is\_subgroup} does not take a subset and return a subgroup. It is simply the assertion that the set \textbf{s} is also a subgroup.

A term \textbf{h : is\_subgroup s} is effectively the statement that the propositions \textbf{mul\_mem}, \textbf{one\_mem}, and \textbf{inv\_mem} hold. Likewise, in order to prove \textbf{is\_subgroup s} it is necessary to prove that all three of these propositions hold for \textbf{s}.

We can similarly define a normal subgroup, which extends the subgroup structure.

\vspace{2 mm}
\hspace{2 em}\textbf{class is\_normal\_subgroup [group $\a$] (s : set $\a$) extends is\_subgroup s : Prop :=}

\hspace{4 em}\textbf{(normal : $\forall n \in s,\; \forall g : \a,\; g * n * g^{-1} \in s$)}
\vspace{2 mm}

For example, 

\vspace{2 mm}
\hspace{2 em}\textbf{def trivial (group $\a$) : set $\a$ := \{1\}}
\vspace{2 mm}

We can define the set \textbf{trivial}, which it is then easy to prove is a normal subgroup.

\vspace{2 mm}
\hspace{2 em}\textbf{lemma trivial\_in [h : group $\a$] : is\_normal\_subgroup (trivial h) :=}

\hspace{4 em}\textbf{by refine \{..\}; simp}
\vspace{2 mm}

\textbf{refine} is a tactic (part of Lean's automation of theorem proving) which splits the goal of proving \textbf{is\_normal\_subgroup (trivial h)} into four goals: \textbf{mul\_mem}, \textbf{one\_mem}, \textbf{inv\_mem}, and \textbf{normal}. \textbf{simp} is a powerful tactic which is used for automatically simplifying statements -- in this case, it is sufficient to prove all four goals.\\


\todo[inline]{Center example}

\todo[inline]{Proof that subgroup is a group}

\section{Homomorphisms}

Given two types $\a$ and $\b$, we can construct the type of functions between them, $\a \to \b$. We can then define the assertion that a function is a homomorphism as follows.

\vspace{2 mm}
\hspace{2 em}\textbf{class is\_hom [group $\a$] [group $\b$] (f : $\a \to \b$) : Prop :=}

\hspace{4 em}\textbf{(hom\_mul : $\forall a\; b,\; f\; (a * b) = f\; a * f\; b$)}
\vspace{2 mm}

This definition is a good example of the benefits of the elaborator. On the left side of the equality, $a * b$ is multiplication of terms of type $\a$, which is possible because the elaborator can determine that since $\a$ is a group, we have that \textbf{has\_mul $\a$}. On the right side of the equality, $f\; a * f\; b$ is multiplication of terms of type $\b$. Lean supports this overloading of the notation $*$, using type class inference to determine which operator to use.\\

We can also define certain structures based on the existence of homomorphisms.

\vspace{2 mm}
\hspace{2 em}\textbf{def kernel [G : group $\a$] [H : group $\b$] \{f : $\a \to \b$\} (hf : is\_hom f) : set $\a$ :=}

\hspace{4 em}\textbf{preimage f (trivial H)}
\vspace{2 mm}

\textbf{preimage} is already defined in Lean -- it is the preimage of \textbf{trivial H}, where \textbf{f} is considered as a function on sets. We need to show that it is a normal subgroup of $\a$, which we can do by showing the more general proposition that the preimage of a normal subgroup is a normal subgroup.

\vspace{2 mm}
\hspace{0 em}\textbf{lemma preimage\_norm\_in {f : $\a \to \b$} (hf : is\_hom f) (S : set $\b$) [is\_normal\_subgroup S]}

\hspace{2 em}\textbf{: is\_normal\_subgroup (preimage f S) :=}

\hspace{4 em}\textbf{by refine \{..\}; simp [hf.hom\_mul, hf.one, hf.inv]}
\vspace{2 mm}

The terms in square brackets after \textbf{simp} are additional lemmas which the \textbf{simp} tactic can use to simplify the goals.\\

We also prove some important lemmas to do with kernels (note that each of the type signatures below should also contain the implicit arguments \textbf{[G : group $\a$] [H : group $\b$]}).

\begin{lemma}
Let $G$ and $G'$ be groups, and $f: G \to G'$ a homomorphism. Then for all $a,b \in G$, $f\; a = f\; b$ if and only if $a * b^{-1} \in \ker (f)$.
\end{lemma}

\vspace{2 mm}
\hspace{2 em}\textbf{lemma kernel\_iff\_equiv \{f : $\a \to \b$\} (hf: is\_hom f) (a b : $\a$)}

\hspace{4 em}\textbf{: $f\; b = f\; a \leftrightarrow a^{-1} * b \in$ hf.kernel}
\vspace{2 mm}

\begin{lemma}
Let $G$ and $G'$ be groups, and $f: G \to G'$ a homomorphism. Then $f$ is injective if and only if $\ker (f)$ is the trivial subgroup of $G$. 
\end{lemma}

\vspace{2 mm}
\hspace{2 em}\textbf{lemma inj\_iff\_trivial\_kernel \{f : $\a \to \b$\} (hf: is\_hom f)}

\hspace{4 em}\textbf{: function.injective f $\leftrightarrow$ hf.kernel = trivial G}
\vspace{2 mm}

The proofs of these lemmas are fairly simple, and the proofs in Lean closely follow the intuitive proofs.

\section{Cosets}

Given \textbf{\{$\a$ : Type u\} [has\_mul $\a$] (a : $\a$) (S : set $\a$)}, we can construct the left and right cosets of \textbf{S} by \textbf{a}.

\vspace{2 mm}
\hspace{2 em}\textbf{def lcoset [has\_mul $\a$] (a : $\a$) (S : set $\a$) : set $\a$ := image ($\l\; x,\; a * x$) S}

\hspace{2 em}\textbf{def rcoset [has\_mul $\a$] (S : set $\a$) (a : $\a$)  : set $\a$ := image ($\l\; x,\; x * a$) S}
\vspace{2 mm}

Here we introduce another powerful feature of Lean's dependent type theory -- lambda expressions. The expression $\l\; x,\; a * x$ is a function, with the arguments to the left of the comma and the result to the right. In this case, it is a function which takes an element $x$ of the set $S$ and returns $a * x$. The image of this function is clearly the left coset of $S$ by $a$, as we require.

We can then introduce some notation to mirror the informal notation $aS$, which is commonly used to denote the left coset of $S$ by $a$.

\vspace{2 mm}
\hspace{2 em}\textbf{namespace coset\_notation}

\hspace{4 em}\textbf{infix $*$ := lcoset}

\hspace{4 em}\textbf{infix $*$ := rcoset}

\hspace{2 em}\textbf{end coset\_notation}
\vspace{2 mm}

By overloading the notation $*$, we now enable ourselves to write $a * S$ and $S * a$ to denote the left coset and right coset respectively. Lean's type class inference is able to determine when $*$ means multiplication, and when it means a coset.

In addition to several simple lemmas about cosets, we prove two main lemmas.

\begin{lemma}
Let $G$ be a group and $S$ a subgroup. Then the relation $a \sim b \iff aS = bS$ is an equivalence relation.
\end{lemma}

\vspace{2 mm}
\hspace{2 em}\textbf{def lcoset\_equiv (S : set $\a$) (a b : $\a$) := $a * S = b * S$}
\vspace{2 mm}

Equivalence relations are defined as expected in Lean. Given \textbf{{$\a$ : Sort u} {$\b$ : Sort v} (r : $\b \to \b \to$ Prop)}\footnote{\textbf{Sort u} is (barring some slight nuances) another way of saying \textbf{Type (u-1)}}, where \textbf{r} is a relation, we define:

\vspace{2 mm}
\hspace{2 em}\textbf{def reflexive := $\forall$ x, r x x}

\hspace{2 em}\textbf{def symmetric := $\forall$ {x y}, r x y $\to$ r y x}

\hspace{2 em}\textbf{def transitive := $\forall$ {x y z}, r x y $\to$ r y z $\to$ r x z}

\hspace{2 em}\textbf{def equivalence := reflexive r $\land$ symmetric r $\land$ transitive r}
\vspace{2 mm}

\textbf{Sort u} is (barring some slight nuances) another way of saying \textbf{Type (u-1)}

We also have a constructor \textbf{mk\_equivalence}, which takes proofs of \textbf{reflexive r}, \textbf{symmetric r}, and \textbf{transitive r}, and creates a proof that $r$ is an equivalence relation. With this in mind, we can provide a very simple proof:

\vspace{2 mm}
\hspace{2 em}\textbf{lemma lcoset\_equiv\_rel (S : set $\a$) : equivalence (lcoset\_equiv S) :=}

\hspace{4 em}\textbf{mk\_equivalence (lcoset\_equiv S) ($\l\; a$, rfl) ($\l\;a\;b$, eq.symm) ($\l\;a\;b\;c$, eq.trans)}
\vspace{2 mm}

The simplicity of these proofs relies on the fact that cosets are defined as the image of multiplication, which allows Lean to use lemmas about multiplication in the proofs.

\begin{lemma}
Let $G$ be a group and $S$ a subgroup of $G$. Then $S$ is a normal subgroup if and only if for all $g \in S$, $gS = Sg$.
\end{lemma}

\vspace{2 mm}
\hspace{2 em}\textbf{theorem normal\_iff\_eq\_cosets : is\_normal\_subgroup S $\leftrightarrow \forall g,\; g * S = S * g$}
\vspace{2 mm}

\todo[inline]{The proof of this is quite interesting, so I'd like to talk about it, but I'm not sure how to discuss the interesting parts of the proof without detailing the whole of the proof (which is pretty much impossible to explain properly in limited space, since it relies on a lot of tactics)}

\section{Quotient Groups}

Suppose we have a type $\a$ and an equivalence relation \textbf{r} on $\a$. Then we can consider the "quotient" $\a$ / \textbf{r}, the set of equivalence classes of $\a$ modulo \textbf{r}. Given a function $f : \a \to \b$, if we prove \textit{for all $a, b \in \a$, $a \sim b \implies f \; a = f\; b$} (in other words, that $f$ respects the equivalence relation), then $f$ "lifts" to a function $f' : \a / \textbf{r} \to \b$, defined on each equivalence class $[x]$ with $f'\; [x] = f\; x$.

The Calculus of Inductive Constructions that Lean is based on has no in-built way to define quotients, so they are added using constants. Before we discuss these constants, however, we must introduce setoids.

\subsection{Setoids}

A setoid is simply a set with an equivalence relation on it. In Lean, a setoid is defined as

\vspace{2 mm}
\hspace{2 em}\textbf{class setoid ($\a$ : Sort u) :=}

\hspace{4 em}\textbf{(r : $\a \to \a \to$ Prop)}

\hspace{4 em}\textbf{(iseqv : equivalence r)}
\vspace{2 mm}

\subsection{Quotients in Lean}

A constant in Lean is simply the statement that a certain identifier has a certain type. This allows to construct new types. Effectively, it is the addition of certain axioms into Learn. 

The following constants are built into Lean:

\vspace{2 mm}
\hspace{2 em}\textbf{constant quotient \{$\a$ : Sort u\} (s : setoid $\a$) : Sort u}

\vspace{4 mm}

\hspace{2 em}\textbf{constant quotient.mk \{$\a$ : Sort u\} [s : setoid $\a$] (a : $\a$) : quotient s}

\vspace{4 mm}

\hspace{2 em}\textbf{constant lift \{$\a$ : Sort u\} \{$\b$ : Sort v\} [s : setoid $\a$] (f : $\a \to \b$)}

\hspace{4 em}\textbf{: ($\forall$ a b, a $\sim$ b $\to$ f a = f b) $\to$ quotient s $\to \b$}

\vspace{4 mm}

\hspace{2 em}\textbf{constant ind \{$\a$ : Sort u\} [s : setoid $\a$] \{$\b$ : quotient s $\to$ Prop\} }

\hspace{4 em}\textbf{: ($\forall$ a, $\b$ [a]) $\to \forall$ q, $\b$ q}

\vspace{4 mm}

\hspace{2 em}\textbf{constant sound \{$\a$ : Sort u\} [s : setoid $\a$] \{a b : $\a$\} : a $\sim$ b $\to$ [a] = [b]}
\vspace{2 mm}

\textbf{quotient} constructs a new type given any setoid \textbf{s}. The axioms following it (in particular, \textbf{sound}) make this new type exactly the quotient we would expect: the set of equivalence classes of the relation \textbf{setoid.r}.

\textbf{quotient.mk} maps $\a$ to \textbf{quotient s}. Given a term \textbf{a : $\a$}, \textbf{quotient.mk a} is the term of type \textbf{quotient s} corresponding to the equivalence class of \textbf{a}.

If we are given any function \textbf{f :} $\a \to \b$, and given a proof \textbf{h} that $f$ respects the quotient, the function \textbf{lift f h : quotient s $\to \b$} is the corresponding function on \textbf{quotient s}.

\textbf{ind} is the statement that in order to prove a statement of the form

\vspace{2 mm}
\hspace{2 em}\textit{for all t in quotient s, p s}
\vspace{2 mm}

it is sufficient to prove

\vspace{2 mm}
\hspace{2 em}\textit{for all a in $\a$, p [a]}.
\vspace{2 mm}

Finally, \textbf{sound} is the axiom that ensures the quotient construction indeed acts how we expect it to -- that if $a \sim b$, then $[a] = [b]$. (The converse of this is encoded as a lemma called \textbf{quotient.exact}.)


\section{First Isomorphism Theorem}

\section{Alternative Subgroup Construction}

\todo[inline]{I'm thinking of discussing the alternative subgroup construction we discussed (where the subgroups were actual subgroups rather than simply the statement that a set is a subgroup) and discussing the pros/cons between that and the construction given. That may require spending too much time on something with little relevance, however.}

\todo[inline]{Sets}

\begin{thebibliography}{1}

\bibitem{lean} L. de Moura, S. Kong, J. Avigad, F. van Doorn, J. von Raumer. {\em The Lean Theorem Prover (system description).} Microsoft Research and Carnegie Mellon University. Research Showcase @ CMU. 2015.

\bibitem{artin} M. Artin. {\em Algebra, 2nd Edition.} Pearson. 2010.

\bibitem{type} H. Geuvers. {\em Introduction to Type Theory.} Radboud University Nijmegen and Technical University Eindhoven. 2008.

\bibitem{tpl} Theorem Proving in Lean.

\bibitem{mathlib} Mathlib (how to reference?)

\end{thebibliography}

\end{document}
