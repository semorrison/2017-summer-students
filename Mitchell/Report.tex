\documentclass[runningheads,a4paper]{llncs}

\usepackage[utf8]{inputenc}

\usepackage[square,sort,comma,numbers,sectionbib]{natbib}
\bibliographystyle{apalike-fr}
\renewcommand{\bibname}{References}

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{amsopn}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{todonotes}

\topmargin=0in
\evensidemargin=0.25in
\oddsidemargin=0.25in
\textwidth=6in
\textheight=9.0in
\headsep=0.25in

\linespread{1.1}

%Blackboard Bold
\newcommand{\C}{\mathbb{C}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\N}{\mathbb{N}}

%Calligraphic
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cB}{\mathcal{B}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cL}{\mathcal{L}}

%Greek
\renewcommand{\a}{\alpha}
\newcommand{\z}{\zeta}
\renewcommand{\b}{\beta}
\newcommand{\g}{\gamma}
\newcommand{\e}{\varepsilon}
\renewcommand{\d}{\delta}
\renewcommand{\r}{\rho}
\renewcommand{\l}{\lambda}
\newcommand{\w}{\omega}
\newcommand{\n}{\eta}
\newcommand{\f}{\varphi}
\newcommand{\s}{\sigma}
\renewcommand{\t}{\tau}
\newcommand{\tr}{\tilde \rho}


%Sets and Logic
\newcommand{\sub}{\subseteq}
\newcommand{\imp}{\implies}
\newcommand{\x}{\times}
\DeclareMathOperator{\End}{End}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\im}{im}
\renewcommand{\-}{\setminus}
\DeclareMathOperator{\id}{id}

%Linear Algebra
\newcommand{\bop}{\bigoplus}
%\newcommand{\tr}{\text{tr}}

\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\begin{document}

\mainmatter 

\title{Group Theory in Lean}

\titlerunning{Group Theory in Lean}

\author{Mitchell Rowett}

\institute{Interactive Theorem Proving}

\authorrunning{Mitchell Rowett}

\toctitle{Abstract}
\tocauthor{{}}

\maketitle

\medskip

\begingroup
\let\clearpage\relax
\tableofcontents
\endgroup

\section*{Abstract}

In this report, we describe a formalisation of elementary group theory in the proof assistant Lean. We begin with an introduction to interactive theorem proving, and to the Lean Theorem Prover in particular. We then detail the construction of this formalisation in Lean, culminating in a proof of the first isomorphism theorem.

\section{Introduction}

Computational formal verification of mathematical theorems comes in two main forms. Automated theorem proving focuses on proving assertions fully automatically, with little or no input from a user. Interactive theorem proving involves a user actively guiding the proof, and builds mathematical structures from a suitable axiomatic framework.

Lean is primarily an interactive theorem prover, with a variety of automated tools. It encodes a formal mathematical language, based on dependent type theory, as well as a method for checking the correctness of terms written in this language.

\section{Lean Theorem Prover}

Lean is a proof assistant which encodes a variety of dependent type theory (described below) and provides a method for checking derivations made in that encoding. Lean also provides many features which aid the user in defining objects and proving theorems, the most relevant of which are discussed later in this section.

\subsection{Type Theory}

A type theory is a formal system in which every term has a type, and operations are restricted to terms of a certain type. It is built by specifying judgments and rules. The basic judgment in type theory is of the form $a : A$, which is read as the statement `a is a term of type A'. Further, operations can be defined with types. The judgment $f : A \to B$ is the statement that $f$ has the type of a function with domain $A$ and co-domain $B$.

Type theory allows the construction of further objects, given prior judgments. For example, the expression
\[
4 * (5 + 7) : \textbf{nat}
\]
is a type judgment states that $4 * (5 + 7)^8$ is of type \textbf{nat}, which is true because 4, 5, and 7 are of type \textbf{nat}, while $*$ and $+$ are operations on natural numbers.\\

The simple type theory described above is limited in that the only types which exist are the types built into the language and those which can be constructed using $\to$ (i.e. functions from one type to another). Simple type systems generally have other simple constructions as well -- for example, a conjuction operator which gives types of the form $A \land B$.

There are many types which cannot be described using this system -- for example, a list of terms where all the terms are of type $A$, expressed as the type `list $A$'. The construction of this type clearly depends on the type $A$, hence a type theory where constructions of this form are possible is called a dependent type theory.\\

Type systems are commonly used in programming languages to check the syntactic correctness of code. For example, if $x$ is given as an argument to a function which takes an integer as an argument, then a type system as described above can be used to check whether $x$ indeed has the type integer, and so can provide a compile-time check of the syntactic correctness of the program.

Proof assistants can use the same method of type checking to ensure the correctness of a mathematical proof of some theorem, by relying on the Curry-Howard isomorphism. The isomorphism simply amounts to a correspondence between two possible readings of the judgment
\[
p : A
\]
\begin{itemize}
\item $p$ is a term (variable, function output) of the data type $A$
\item $p$ is a proof of the hypothesis $A$
\end{itemize}

To generalise, the former is how a programmer would understand the judgment, while the latter is the point of view of a proof theorist. Interactive theorem provers use both, in which a term (proof) of the correct type (hypothesis) is sought interactively by both the user and the system. In other words, a type checking algorithm can be used to check whether $p$ is a correct proof of the hypothesis $A$, as this will be the case if and only if $p$ is a correct term of the type $A$.

In this manner, Lean encodes a dependent type theory called the Calculus of Inductive Constructions (CIC).

\subsection{Elaboration}

One issue proof assistants run into is that building more complex structures can require a lot of details. In 'pen-and-paper' mathematics, these details are omitted as they can be easily inferred.

To facilitate this, Lean has an elaborator, which allows the user to leave arguments implicit by putting them in curly brackets when defining a function. The elaborator will then convert this partially specified expression into a fully specified, type correct term. For example, Lean defines the identity function as

\vspace{2 mm}
\hspace{4 em}\textbf{def id \{$\a$ : Type\} (a : $\a$) : $\a$ := a}
\vspace{2 mm}

Unpacking this definition will show most of the essential lean syntax. The \textbf{def} keyword creates a function called \textbf{id}. The next two terms, \textbf{\{$\a$ : Type\} (a : $\a$)}, are arguments to the function -- $\a$ is a Type, while \textbf{a} is a term of type $\a$. The syntax \textbf{: $\a$} means that the result of the function will be a term of type $\a$, and \textbf{:= a} is the result of the function -- given a type $\a$ and a term of that type \textbf{a}, return \textbf{a}.

Note, however, the difference between the syntax of the two arguments. The use of curly brackets allows the user to write \textbf{id a} rather than \textbf{id A a}. The elaborator can infer the type required.\\

The elaborator also supports overloading. For example, we later use the following: let $a$ and $b$ be elements of a group $G$, and $S$ a subgroup of $G$. Then $a*b$ is used to denote group multiplication, while $a * S$ is used to denote the left coset of $S$ by $a$. The elaborator also inserts coercions (for example, from \textbf{nat} to \textbf{int}) where necessary.

\subsection{Type Class Inference}

Another way in which the elaborator allows details to be omitted is through type class inference, which works as follows. First, a structure is marked as a class. Then, an instance of this class is declared, either by adding it as a hypothesis or by proving that it must be present due to existing hypotheses. Finally, in any definition/theorem/lemma in which this structure is used, we can mark the argument as implicit using square brackets rather than curly brackets, which informs the elaborator that these arguments should be inferred by the type class mechanism.

A relevant example of type class inference is the construction of the group structure.

\subsection{Group Construction}

Without any kind of implicit arguments, the statement $\forall a\; b : \a,\; a*b : \a$ would be insufficient on its own. We would need to give as an argument to $*$ the fact that multiplication on terms of type $\a$ is actually possible. However, using type class inference we can get around this:

\vspace{2 mm}
\hspace{4 em}\textbf{class has\_mul ($\a$ : Type u) := (mul : $\a \to \a \to \a$)}
\vspace{2 mm}

This means that a proof or hypothesis $p$ : has\_mul $\a$ is the statement that $\a$ is a type with multiplication, and so we can write (for example) $\forall a\; b : \a,\; a*b : \a$. Further, since it is a class, we do not have to explicitly tell Lean that this is possible. So long as $p$ is in the context, we can write $a * b$, and the elaborator will use type class inference to check that multiplication on terms of type $\a$ is possible.

Type class inference can also use the information that one type marked as a class inherits from another type marked as a class. For example:

\vspace{2 mm}
\hspace{4 em}\textbf{class semigroup ($\a$ : Type u) extends has\_mul $\a$
 := }

\hspace{6 em}\textbf{(mul\_assoc : $\forall a\; b\; c : \a, a * b * c = a * (b * c)$)}
\vspace{2 mm}


\section{Group Theory}

In this section we will review the elementary group theory\cite{artin} which will be formalised in this report.

\begin{definition}[Group] 
A group is a set $G$ together with an operation $* : G \times G \to G$, which we will call multiplication, such that:
\begin{itemize}
\item $G$ is closed under multiplication: for all $a$ and $b$ in $G$, $a*b$ in $G$
\item Multiplication is associative: for all a, b, c, in $G$, $(a*b)*c = a*(b*c)$
\item G contains an identity element 1: for all a in $G$, $1*a = a$ and $a*1=a$
\item Every element $a$ of $G$ has an inverse, an element $b$ such that $a*b = 1$ and $b*a =1$
\end{itemize}

We denote the inverse of $a$ as $a^{-1}$.
\end{definition}

\subsection{Subgroups}

\begin{definition}[Subgroup]
A subset $H$ of a group $G$ is a subgroup if it has the following properties:
\begin{itemize}
\item Closure: If a and b are in H, then $a * b$ is in H
\item Identity: 1 is in H
\item Inverses: If a is in H, then $a^{-1}$ is in H
\end{itemize}
\end{definition}

\begin{definition}[Normal]
A subgroup N of a group G is a normal subgroup if for every a in N and every g in G, $g * a * g^{-1}$ is in N.
\end{definition}

\begin{definition}[Trivial Subgroup] The set containing only 1 is a subgroup, and is called the trivial subgroup.
\end{definition}

\begin{definition}[Center]
The center of a group G is the set of elements that commute with every element of G:
\[
\left\{ z \in G \mid z*x = x*z \text{ for all } x \in G \right\}
\]
\end{definition}

\begin{definition}[Left Coset]
If H is a subgroup of a group G and a is an element of G, then the left coset of H by a is 
\[
a * H = \{ g \in G \mid g = a * h \text{ for some } h \in H \}
\]
We similarly define the right coset of H by a and denote it $H * a$.
\end{definition}

\subsection{Homomorphisms}

\begin{definition}[Homomorphism]
Homomorphism: Let G and G' be groups. A homomorphism $\phi : G \to G'$ is a map from G to G' such that for all a, b in G:
\[
\phi (a * b) = \phi(a) * \phi(b)
\]
\end{definition}

\begin{definition}[Kernel]
Suppose G and G' are groups, and let $\phi : G \to G'$ be a homomorphism. The kernel of $\phi$ is the set of elements of G which are mapped to the identity in G'.
\[
\left\{ a \in G \mid \phi(a) = 1 \right\}
\]
\end{definition}

\begin{definition}[Quotient Group]
Let G be a group, and N a normal subgroup. Then there is an equivalence relation on elements of G, given by $a \sim b$ if $a * b^{-1} \in N$. The equivalence class of b given by this relation is denoted $[b]$, and the set of equivalence classes is denoted $G/N$. $G/N$ is a group, and is called the quotient of G by N.
\end{definition}

\begin{definition}[Isomorphism]
A homomorphism is called an isomorphism if it is bijective. Two groups are said to be isomorphic if there exists an isomorphism between them.
\end{definition}

\begin{theorem}[First Isomorphism Theorem]
Let G and G' be groups, and let $\phi : G \to G'$ be a homomorphism. Let K be the kernel of $\phi$. Note that the image of $\phi$ forms a group. Then $G/K$ is isomorphic to the image of $\phi$.
\end{theorem}


\section{Homomorphisms}

\section{Subgroups}

\section{Cosets}

\section{Quotient Groups}

\section{First Isomorphism Theorem}

\begin{thebibliography}{1}

\bibitem{lean} L. de Moura, S. Kong, J. Avigad, F. van Doorn, J. von Raumer. {\em The Lean Theorem Prover (system description).} Microsoft Research and Carnegie Mellon University. Research Showcase @ CMU. 2015.

\bibitem{artin} M. Artin. {\em Algebra, 2nd Edition.} Pearson. 2010.

\bibitem{type} H. Geuvers. {\em Introduction to Type Theory.} Radboud University Nijmegen and Technical University Eindhoven. 2008.

\bibitem{tpl} Theorem Proving in Lean.

\bibitem{mathlib} Mathlib (how to reference?)

\end{thebibliography}

\end{document}
