import data.list.basic
theorem test (p q : Prop) (hp : p) (hq : q) : p ∧ q ∧ p := begin
  apply and.intro,
  exact hp,
  apply and.intro,
  exact hq,
  exact hp
  end
-- "apply" tries to match its argument's output to the main goal
-- if it succeeds, it would then try to fill in the argument's arguments
-- and add those that are filled, to the subgoals.
-- "exact" is a special "apply". more robust than the general "apply"

#print test -- shows the proof generated by the tactic block

section
-- "intro" is similar to "assume"
-- its plural form is "intros"
example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := begin
  apply iff.intro,
    intro h,
    apply or.elim (and.right h),
      intro hq,
      apply or.inl,
      apply and.intro,
        exact and.left h,
      exact hq,
    intro hr,
    apply or.inr,
    apply and.intro,
      exact and.left h,
    exact hr,
  intro h,
  apply or.elim h,
    intro hpq,
    apply and.intro,
      exact and.left hpq,
    apply or.inl,
    exact and.right hpq,
  intro hpr,
  apply and.intro,
    exact and.left hpr,
  apply or.inr,
  exact and.right hpr
end

theorem tr : ∀ a b c : ℕ, a = b → a = c → c = b :=
begin
  intros _ _ _ h₁ h₂,
  exact eq.trans h₂.symm h₁
end
#print tr

variable α : Type
variables (x y z w : α)
example (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w :=
begin
  apply h₁.trans, apply h₂.trans, 
  assumption -- "assumption" is a kind of "exact", but only checks the 
  -- "local context" (current assumptions).
end

example (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := 
begin
  apply eq.trans, assumption, apply eq.trans, assumption, assumption
end
-- "refl" is like "apply eq.refl", but it works for any goal "x ~ y"
-- where "~" is tagged with the refl attribute.
example (y : ℕ) : (λ x : ℕ, 0) y = 0 := by refl
example (x : ℕ) : x ≤ x := by reflexivity

-- "transitivity", "symmetry" are like "refl"
example : ∀ a b c : ℕ, a = b → a = c → c = b :=
begin
  intros, transitivity a, symmetry, 
  repeat {assumption}
end
-- curly braces introduce a new tactic block

example : ∃ a : ℕ, 5 = a :=
begin
  apply exists.intro, -- the second goal depends on the first goal
  refl -- the second goal is got while getting the first
end

-- fapply forces the goals to stay in the same order
example : ∃ a : ℕ, a = a :=
begin
  fapply exists.intro, exact 0, refl
end

example : ∃ a : ℕ, a = a :=
begin
  apply exists.intro, refl, exact 0
end

-- "revert" is the opposite of "intro"
example (x y : ℕ) (h : x = y) : y = x :=
begin
  revert x, -- it reverts x, as well as h, which depends on x
  intros,
  symmetry,
  assumption
end

example : 2 + 3 = 5 :=
begin
  generalize h : 3 = x, 
  -- generalize does a substitution to the goal,
  -- and records the substitution in the local context
  rw ←h
end
end

section
-- "left", "right" are "apply or.inl", "apply or.inr"
-- "cases" can decompose ∨ and ∧ 
example (p q : Prop) : p ∨ q → q ∨ p :=
begin
  intro h,
  cases h with hp hq,
  right, exact hp,
  left, exact hq
end

example (p q : Prop) : p ∧ q → q ∧ p :=
begin
  intro h,
  cases h with hp hq,
  constructor, -- here, equivalent to "apply and.intro"
  exact hq, exact hp
end

example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=
begin
  constructor,
  intro h,
    cases h with hp hqr,
    cases hqr with hq hr,
      left, exact (and.intro hp hq),
      right, exact (and.intro hp hr),
  intro h, 
    cases h with hpq hpr, 
      cases hpq with hp hq,
        exact (and.intro hp (or.inl hq)),
      cases hpr with hp hr,
        exact (and.intro hp (or.inr hr)),
end

example (p q : ℕ → Prop) : (∃ x, p x) → ∃ x, p x ∨ q x :=
begin
  intro h,
  cases h with _ px,
  constructor, -- or "existsi x"
  left, exact px
end

example (p q r : ℕ → Prop) :
  (∃ x, p x ∧ q x ∧ r x) → ∃ x, r x ∧ q x ∧ p x :=
begin
  intro h,
  cases h with x hpqr,
  cases hpqr with hp hqr,
  cases hqr with hq hr,
  existsi x,
  repeat { split, repeat { assumption }}
end
-- semicolon after "split" tells Lean to use "assumption" to both goals
-- introduced by splitting the ∧ 

-- "contradiction" finds a contradiction in the local context, 
-- then uses ex falso to get the goal.
example (p q : Prop) : p ∧ ¬ p → q :=
begin
  intro h, cases h, contradiction
end
end

section
-- using tactics for data, because curry-howard isomorphism
universes u v

-- product
def swap_pair {α : Type u} {β : Type v} : α × β → β × α :=
begin
  intro p,
  cases p with ha hb,
  constructor, exact hb, exact ha
end

-- coproduct
def swap_sum {α : Type u} {β : Type v} : α ⊕ β → β ⊕ α :=
begin
  intro p,
  cases p with ha hb,
    right, exact ha,
    left, exact hb
end

open nat

example (P : ℕ → Prop) (h₀ : P 0) (h₁ : ∀ n, P (succ n)) (m : ℕ) :
  P m :=
begin
  cases m with m', 
  -- "cases" decomposes m to cases, one for each constructor of ℕ
  exact h₀, -- case of the nullary constructor, giving 0
  exact h₁ m' -- case of the unary constructor, giving (succ m')
end
end

section
example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) :=
begin
  intro h,
  exact
    have hp : p, from h.left,
    have hqr : q ∨ r, from h.right,
    show (p ∧ q) ∨ (p ∧ r),
    begin
      cases hqr with hq hr,
        exact or.inl ⟨hp, hq⟩,
      exact or.inr ⟨hp, hr⟩
    end
end
end

-- mixing terms and tactics
section
example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=
begin
  constructor,
    intro h,
    cases h.right with hq hr,
      exact or.inl ⟨h.left, hq⟩,
      exact or.inr ⟨h.left, hr⟩,
  intro h,
  cases h with hpq hpr,
    exact ⟨hpq.left, or.inl hpq.right⟩,
    exact ⟨hpr.left, or.inr hpr.right⟩
end

-- "show" tactic selects the goal to be solved
-- in tactic mode, "from" is "exact"
example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=
begin
  apply iff.intro,
    intro h,
    cases h.right with hq hr,
      show (p ∧ q) ∨ (p ∧ r),
        from or.inl ⟨h.left, hq⟩,
      show (p ∧ q) ∨ (p ∧ r),
        from or.inr ⟨h.left, hr⟩,
  intro h,
  cases h with hpq hpr,
    show p ∧ (q ∨ r),
      from ⟨hpq.left, or.inl hpq.right⟩,
    show p ∧ (q ∨ r),
      from ⟨hpr.left, or.inr hpr.right⟩
end

-- "show" can rewrite a goal to something definitionally equivalent
example (n : ℕ) : n + 1 = nat.succ n :=
begin
  show nat.succ n = nat.succ n, refl
end

-- "have" tactic breaks one goal into two subgoals
example (p q r : Prop) : p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r) :=
begin
  intro h,
  cases h with hp hqr,
  cases hqr with hq hr,
    have hpq : p ∧ q, from and.intro hp hq,
    exact or.inl hpq,
  have hpr : p ∧ r, {split; assumption},
  from or.inr hpr
end

-- "let" tactic creates a local context 
example : ∃ x, x + 2 = 8 :=
begin
  let a := 3 * 2,
  existsi a,
  reflexivity
end

-- nested tactic blocks. each block solves its "focused goal"
example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) :=
begin
  apply iff.intro,
  { intro h,
    cases h.right with hq hr,
    { show (p ∧ q) ∨ (p ∧ r),
        exact or.inl ⟨h.left, hq⟩},
    show (p ∧ q) ∨ (p ∧ r),
      exact or.inr ⟨h.left, hr⟩ },
  intro h,
  cases h with hpq hpr,
  { show p ∧ (q ∨ r),
      exact ⟨hpq.left, or.inl hpq.right⟩ },
  show p ∧ (q ∨ r),
    exact ⟨hpr.left, or.inr hpr.right⟩
end
end

section 
-- Tactic combinators are operations on tactics.

--  ; is the "andthen" operator
-- t₁; t₂
-- t₁ is applied to the current goal, 
-- t₂ is applied to all the resulting subgoals
-- It's equivalent to t₁, repeat { t₂ }
example (p q : Prop) : p ∧ q ↔ q ∧ p :=
begin
  constructor,
  repeat { intro a, cases a with a b,
    constructor; assumption }
end

-- <|> is the "orelse" operator
-- t₁ <|> t₂
-- tries t₁, if fail, backtracts and tries t₂. fails if both fail.
-- assoc to the right
example (p q r : Prop) (hr : r) : p ∨ q ∨ r :=
by repeat { {left, assumption} <|> right <|> assumption }

example (p q r : Prop) : p ∧ q ∧ r ↔ r ∧ q ∧ p :=
begin
  constructor,
  repeat { intro a, 
    repeat { cases a with b a }, -- split up the assumption
    repeat { constructor <|> assumption }} -- split up the goal
end
end

section 
-- tactics are objects of type "tactic α", for some α.
meta def solve_disjunction : tactic unit :=
`[ any_goals {
     repeat { {left, assumption} <|> right <|> assumption }} ]

meta def solve_conjunction : tactic unit :=
`[ repeat { any_goals { split <|> assumption }} ]

example (p q r : Prop) (hr : r) : p ∨ q ∨ r :=
by solve_disjunction

-- "all_goals" applies t to all threads
-- it succeeds iff it succeeds in all threads
-- "any_goals", succeeds iff it succeeds in at least one
example (p q r : Prop) (hp : p) (hq : q) (hr : r) :
  p ∧ q ∧ r :=
begin
  split,
  any_goals { split },
  any_goals { assumption }
end

-- focus t
-- applies t only on the first goal, hiding all others
-- solve1 t 
-- succeeds iff t solves the first goal completely
-- done
-- succeeds iff there are no goals
end

section rewrite
-- "rewrite" applies substitutions to goals and hypotheses, 
-- good for equality. 
-- "rewrite t", where t has a type that asserts an equality, like, 
-- hypothesis: h : x = y
-- lemma: add_comm : ∀ x y, x + y = y + x, 
--   where "rewrite" tries to fill in x and y
-- or any compound term asserting a concrete or general equation. 

variables (f : ℕ → ℕ) (a b : ℕ)

-- rw (t1 = t2) uses t2 ▸ t1
-- rw ←(t1 = t2) uses t1 ▸ t2
example (h₁ : a = b) (h₂ : f a = 0) : f b = 0 :=
begin
  rw [←h₁, -- a ▸ b
      h₂]  -- 0 ▸ f a
end

-- to rw a specific part of the goal
example (a b c : ℕ) : a + b + c = a + c + b :=
begin
  rw [add_assoc,    -- + assoc to left
      add_comm b c, -- rw by a specific instance of the theorem
      ←add_assoc]
end

example (a b c : ℕ) : a + b + c = a + c + b :=
begin
  rw [add_assoc, add_assoc, 
      add_comm b] 
      -- (add_comm _ b), (add_comm c), (add_comm _ c) also works
end

-- rw the local context, not the goal
example (h : a + 0 = 0) : f a = f 0 :=
by { rw add_zero at h, -- rw hypothesis h
     rw h }

-- rw for general terms, not just Prop
universe u

example {α : Type u} [ring α] (a b c : α) :
  a * 0 + 0 * b + c * 0 + 0 * a = 0 :=
begin
  rw [mul_zero, mul_zero, zero_mul, zero_mul], 
  -- ←(mul_zero a) won't work
  repeat { rw add_zero }
end

example {α : Type u} [group α] {a b : α} (h : a * b = 1) :
  a⁻¹ = b :=
by rw [←(mul_one a⁻¹), ←h, inv_mul_cancel_left]
end rewrite

section simp
-- some identities in library has [simp] attribute, 
-- simp uses them to iteratively rewrite expression.
variables (x y z : ℕ) (p : ℕ → Prop)
variable  (h : p (x * y))

example : (x + 0) * (0 + y * 1 + z * 0) = x * y :=
begin
  repeat {rw add_zero <|> 
          rw zero_add <|> 
          rw zero_mul <|> 
          rw mul_zero <|> 
          rw mul_one },
end
-- by simp
-- usual identities involving 0 and 1, 
-- add_zero, zero_add, mul_zero, zero_mul, mul_one
-- reducing the goal to x * y = x * y. then refl

include h -- allowing h to appear in tactic mode
example : p ((x + 0) * (0 + y * 1 + z * 0)) :=
by { simp, --  p (x * y)
     assumption }
universe u
variable {α : Type}
open list

example (xs : list ℕ) :
  reverse (xs ++ [1, 2, 3]) = [3, 2, 1] ++ reverse xs :=
by simp

example (xs ys : list α) :
  length (reverse (xs ++ ys)) = length xs + length ys :=
by simp


-- data.list.basic is used here

#print list.append
example (xs : list ℕ) :
  list.reverse (xs ++ [1, 2, 3]) = [3, 2, 1] ++ list.reverse xs :=
by simp

example (xs ys : list α) :
  list.length (list.reverse (xs ++ ys)) = list.length xs + list.length ys :=
by simp

-- "simp at h" simplifies only the hypothesis h
-- "simp at *" simplifies all hypotheses and goals
-- "simp [h, h'.symm, f]" simplifies the main goal using the 
--   default ones, pluse the mentioned hypotheses.

variables (q r s : Prop)
-- simp can do propositional logic term rewriting
example (hp : s) (hq : q) : s ∧ (q ∨ r) :=
by simp *
end simp
section

-- more powerful example of simp
variables (u w x x' y y' z : ℕ) (p : ℕ → Prop)

example (h₁ : x + 0 = x') (h₂ : y + 0 = y') :
  x + y + 0 = x' + y' :=
by { simp at *, simp * }

example (h₁ : x = y + z) (h₂ : w = u + x) (h₃ : p (z + y + u)) :
  p w  :=
by { simp at *, simp * }

-- simp [theorems to use here] at h with my_simp
-- "my_simp" is a name for any attribute tag you created
--   that is supposed to be used by simp, when you specify so.

-- for adding attribute to a theorem,
-- "@[simp] theorem reverse_mk_symm" at definition, or
-- "attribute [simp] reverse_mk_symm" after definition, or
-- "local attribute [simp] reverse_mk_symm" after definition,
--   such that its effect goes away outside the current section

end